/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.sql.catalyst.expressions

import org.apache.spark.SparkException
import org.apache.spark.sql.catalyst.{CatalystTypeConverters, InternalRow, ScalaReflection}
import org.apache.spark.sql.catalyst.expressions.codegen._
import org.apache.spark.sql.catalyst.expressions.codegen.Block._
import org.apache.spark.sql.types.{AbstractDataType, DataType}

/**
 * User-defined function.
 * @param function  The user defined scala function to run.
 *                  Note that if you use primitive parameters, you are not able to check if it is
 *                  null or not, and the UDF will return null for you if the primitive input is
 *                  null. Use boxed type or [[Option]] if you wanna do the null-handling yourself.
 * @param dataType  Return type of function.
 * @param children  The input expressions of this UDF.
 * @param inputPrimitives The analyzer should be aware of Scala primitive types so as to make the
 *                        UDF return null if there is any null input value of these types. On the
 *                        other hand, Java UDFs can only have boxed types, thus this parameter will
 *                        always be all false.
 * @param inputTypes  The expected input types of this UDF, used to perform type coercion. If we do
 *                    not want to perform coercion, simply use "Nil". Note that it would've been
 *                    better to use Option of Seq[DataType] so we can use "None" as the case for no
 *                    type coercion. However, that would require more refactoring of the codebase.
 * @param udfName  The user-specified name of this UDF.
 * @param nullable  True if the UDF can return null value.
 * @param udfDeterministic  True if the UDF is deterministic. Deterministic UDF returns same result
 *                          each time it is invoked with a particular input.
 */
case class ScalaUDF(
    function: AnyRef,
    dataType: DataType,
    children: Seq[Expression],
    inputPrimitives: Seq[Boolean],
    inputTypes: Seq[AbstractDataType] = Nil,
    udfName: Option[String] = None,
    nullable: Boolean = true,
    udfDeterministic: Boolean = true)
  extends Expression with NonSQLExpression with UserDefinedExpression {

  override lazy val deterministic: Boolean = udfDeterministic && children.forall(_.deterministic)

  override def toString: String = s"${udfName.getOrElse("UDF")}(${children.mkString(", ")})"

  // scalastyle:off line.size.limit

  /** This method has been generated by this script

    (1 to 22).map { x =>
      val anys = (1 to x).map(x => "Any").reduce(_ + ", " + _)
      val childs = (0 to x - 1).map(x => s"val child$x = children($x)").reduce(_ + "\n  " + _)
      val converters = (0 to x - 1).map(x => s"lazy val converter$x = CatalystTypeConverters.createToScalaConverter(child$x.dataType)").reduce(_ + "\n  " + _)
      val evals = (0 to x - 1).map(x => s"converter$x(child$x.eval(input))").reduce(_ + ",\n      " + _)

      s"""case $x =>
      val func = function.asInstanceOf[($anys) => Any]
      $childs
      $converters
      (input: InternalRow) => {
        func(
          $evals)
      }
      """
    }.foreach(println)

  */
  private[this] val f = children.size match {
    case 0 =>
      val func = function.asInstanceOf[() => Any]
      (input: InternalRow) => {
        func()
      }

    case 1 =>
      val func = function.asInstanceOf[(Any) => Any]
      val child0 = children(0)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)))
      }

    case 2 =>
      val func = function.asInstanceOf[(Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)))
      }

    case 3 =>
      val func = function.asInstanceOf[(Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)))
      }

    case 4 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)))
      }

    case 5 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)))
      }

    case 6 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)))
      }

    case 7 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)))
      }

    case 8 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)))
      }

    case 9 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)))
      }

    case 10 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)))
      }

    case 11 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)))
      }

    case 12 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)))
      }

    case 13 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)))
      }

    case 14 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)))
      }

    case 15 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)))
      }

    case 16 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)))
      }

    case 17 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)))
      }

    case 18 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)))
      }

    case 19 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)))
      }

    case 20 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      val child19 = children(19)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      lazy val converter19 = CatalystTypeConverters.createToScalaConverter(child19.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)),
          converter19(child19.eval(input)))
      }

    case 21 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      val child19 = children(19)
      val child20 = children(20)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      lazy val converter19 = CatalystTypeConverters.createToScalaConverter(child19.dataType)
      lazy val converter20 = CatalystTypeConverters.createToScalaConverter(child20.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)),
          converter19(child19.eval(input)),
          converter20(child20.eval(input)))
      }

    case 22 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      val child19 = children(19)
      val child20 = children(20)
      val child21 = children(21)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      lazy val converter19 = CatalystTypeConverters.createToScalaConverter(child19.dataType)
      lazy val converter20 = CatalystTypeConverters.createToScalaConverter(child20.dataType)
      lazy val converter21 = CatalystTypeConverters.createToScalaConverter(child21.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)),
          converter19(child19.eval(input)),
          converter20(child20.eval(input)),
          converter21(child21.eval(input)))
      }
  }

  // scalastyle:on line.size.limit
  override def doGenCode(
      ctx: CodegenContext,
      ev: ExprCode): ExprCode = {
    val converterClassName = classOf[Any => Any].getName

    // The type converters for inputs and the result.
    val converters: Array[Any => Any] = children.map { c =>
      CatalystTypeConverters.createToScalaConverter(c.dataType)
    }.toArray :+ CatalystTypeConverters.createToCatalystConverter(dataType)
    val convertersTerm = ctx.addReferenceObj("converters", converters, s"$converterClassName[]")
    val errorMsgTerm = ctx.addReferenceObj("errMsg", udfErrorMessage)
    val resultTerm = ctx.freshName("result")

    // codegen for children expressions
    val evals = children.map(_.genCode(ctx))

    // Generate the codes for expressions and calling user-defined function
    // We need to get the boxedType of dataType's javaType here. Because for the dataType
    // such as IntegerType, its javaType is `int` and the returned type of user-defined
    // function is Object. Trying to convert an Object to `int` will cause casting exception.
    val evalCode = evals.map(_.code).mkString("\n")
    val (funcArgs, initArgs) = evals.zipWithIndex.zip(children.map(_.dataType)).map {
      case ((eval, i), dt) =>
        val argTerm = ctx.freshName("arg")
        val initArg = if (CatalystTypeConverters.isPrimitive(dt)) {
          val convertedTerm = ctx.freshName("conv")
          s"""
             |${CodeGenerator.boxedType(dt)} $convertedTerm = ${eval.value};
             |Object $argTerm = ${eval.isNull} ? null : $convertedTerm;
           """.stripMargin
        } else {
          s"Object $argTerm = ${eval.isNull} ? null : $convertersTerm[$i].apply(${eval.value});"
        }
        (argTerm, initArg)
    }.unzip

    val udf = ctx.addReferenceObj("udf", function, s"scala.Function${children.length}")
    val getFuncResult = s"$udf.apply(${funcArgs.mkString(", ")})"
    val resultConverter = s"$convertersTerm[${children.length}]"
    val boxedType = CodeGenerator.boxedType(dataType)

    val funcInvokation = if (CatalystTypeConverters.isPrimitive(dataType)
        // If the output is nullable, the returned value must be unwrapped from the Option
        && !nullable) {
      s"$resultTerm = ($boxedType)$getFuncResult"
    } else {
      s"$resultTerm = ($boxedType)$resultConverter.apply($getFuncResult)"
    }
    val callFunc =
      s"""
         |$boxedType $resultTerm = null;
         |try {
         |  $funcInvokation;
         |} catch (Exception e) {
         |  throw new org.apache.spark.SparkException($errorMsgTerm, e);
         |}
       """.stripMargin

    ev.copy(code =
      code"""
         |$evalCode
         |${initArgs.mkString("\n")}
         |$callFunc
         |
         |boolean ${ev.isNull} = $resultTerm == null;
         |${CodeGenerator.javaType(dataType)} ${ev.value} = ${CodeGenerator.defaultValue(dataType)};
         |if (!${ev.isNull}) {
         |  ${ev.value} = $resultTerm;
         |}
       """.stripMargin)
  }

  private[this] val resultConverter = CatalystTypeConverters.createToCatalystConverter(dataType)

  lazy val udfErrorMessage = {
    val funcCls = function.getClass.getSimpleName
    val inputTypes = children.map(_.dataType.catalogString).mkString(", ")
    val outputType = dataType.catalogString
    s"Failed to execute user defined function($funcCls: ($inputTypes) => $outputType)"
  }

  override def eval(input: InternalRow): Any = {
    val result = try {
      f(input)
    } catch {
      case e: Exception =>
        throw new SparkException(udfErrorMessage, e)
    }

    resultConverter(result)
  }

  val expr = {
    try {
      CatalystExpressionBuilder(function)(children)
    } catch {
      case e: SparkException =>
        // scalastyle:off println
        System.err.println("UDF compilation failure: " + e)
        None
        // scalastyle:on println
    }
  }
}

case class CatalystExpressionBuilder(private val function: AnyRef) {

  import com.sun.tools.classfile.Opcode
  import java.lang.reflect.Method
  import jdk.vm.ci.meta.ConstantPool
  import jdk.vm.ci.meta.JavaKind
  import jdk.vm.ci.meta.PrimitiveConstant
  import jdk.vm.ci.meta.ResolvedJavaMethod.Parameter
  import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime
  import jdk.vm.ci.hotspot.HotSpotObjectConstant
  import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod
  import org.apache.spark.sql.types.{DoubleType, LongType}
  import scala.annotation.tailrec
  import scala.collection.immutable.IntMap
  import scala.collection.immutable.SortedMap
  import scala.collection.immutable.SortedSet

  final private val lambdaReflection = LambdaReflection(function)
  final private val cfg = CFG(lambdaReflection)

  def apply(children: Seq[Expression]): Option[Expression] = {
    val entryState = State(lambdaReflection, children)
    val entryBlock = cfg.basicBlocks.head
    apply(List(entryBlock), Map(entryBlock -> entryState))
  }

  @tailrec
  private def apply(
      worklist: List[BB],
      states: Map[BB, State],
      pending: Map[BB, Int] = cfg.pred.mapValues { v => v.size },
      visited: Set[BB] = Set()): Option[Expression] = {
    val basicBlock::rest = worklist
    val state = states(basicBlock)
    val newState = (state /: basicBlock.instructionTable) { (st, i) =>
      i._2(basicBlock, st)
    }
    val newStates = basicBlock.propagateCond(states + (basicBlock -> newState))
    if (basicBlock.lastInstruction.isReturn) {
      newStates(basicBlock).expr
    } else {
      val newVisited = visited + basicBlock
      val (readySucc, newPending) =
        ((List[BB](), pending) /: cfg.succ(basicBlock)) { case (x@(r, np), s) =>
          if (newVisited(s)) {
            x
          } else {
            val count = np(s) - 1
            if (count > 0) (r, np + (s -> count)) else (s::r, np - s)
          }
        }
      apply(
        readySucc:::rest,
        newStates,
        newPending,
        newVisited)
    }
  }

  @tailrec
  private def simplify(expr: Expression): Expression = {
    def simplifyExpr(expr: Expression): Expression = {
      expr match {
        case And(Literal.TrueLiteral, c) => simplifyExpr(c)
        case And(c, Literal.TrueLiteral) => simplifyExpr(c)
        case And(Literal.FalseLiteral, c) => Literal.FalseLiteral
        case And(c1@LessThan(s1, Literal(v1, t1)),
                 c2@LessThan(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                   t1 match {
                     case DoubleType =>
                       if (v1.asInstanceOf[Double] < v2.asInstanceOf[Double]) {
                         c1
                       } else {
                         c2
                       }
                     case _ => expr
                   }
                 }
        case And(c1@LessThanOrEqual(s1, Literal(v1, t1)),
                 c2@LessThanOrEqual(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                   t1 match {
                     case DoubleType =>
                       if (v1.asInstanceOf[Double] < v2.asInstanceOf[Double]) {
                         c1
                       } else {
                         c2
                       }
                     case _ => expr
                   }
                 }
        case And(c1@LessThanOrEqual(s1, Literal(v1, t1)),
                 c2@LessThan(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                   t1 match {
                     case DoubleType =>
                       if (v1.asInstanceOf[Double] <= v2.asInstanceOf[Double]) {
                         c1
                       } else {
                         c2
                       }
                     case _ => expr
                   }
                 }
        case And(c1@GreaterThan(s1, Literal(v1, t1)),
                 c2@GreaterThan(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                   t1 match {
                     case DoubleType =>
                       if (v1.asInstanceOf[Double] > v2.asInstanceOf[Double]) {
                         c1
                       } else {
                         c2
                       }
                     case _ => expr
                   }
                 }
        case And(c1@GreaterThan(s1, Literal(v1, t1)),
                 c2@GreaterThanOrEqual(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                   t1 match {
                     case DoubleType =>
                       if (v1.asInstanceOf[Double] >= v2.asInstanceOf[Double]) {
                         c1
                       } else {
                         c2
                       }
                     case _ => expr
                   }
                 }
        case And(c1, c2) => And(simplifyExpr(c1), simplifyExpr(c2))
        case Or(Literal.TrueLiteral, c) => Literal.TrueLiteral
        case Or(Literal.FalseLiteral, c) => simplifyExpr(c)
        case Or(c, Literal.FalseLiteral) => simplifyExpr(c)
        case Or(c1@GreaterThan(s1, Literal(v1, t1)),
                c2@GreaterThanOrEqual(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                  t1 match {
                    case DoubleType =>
                      if (v1.asInstanceOf[Double] < v2.asInstanceOf[Double]) {
                        c1
                      } else {
                        c2
                      }
                    case _ =>
                      expr
                  }
                }
        case Or(c1, c2) => Or(simplifyExpr(c1), simplifyExpr(c2))
        case Not(Literal.TrueLiteral) => Literal.FalseLiteral
        case Not(Literal.FalseLiteral) => Literal.TrueLiteral
        case Not(LessThan(c1, c2)) => GreaterThanOrEqual(c1, c2)
        case Not(LessThanOrEqual(c1, c2)) => GreaterThan(c1, c2)
        case Not(GreaterThan(c1, c2)) => LessThanOrEqual(c1, c2)
        case Not(GreaterThanOrEqual(c1, c2)) => LessThan(c1, c2)
        case EqualTo(Literal(v1, _), Literal(v2, _)) =>
          if (v1 == v2) Literal.TrueLiteral else Literal.FalseLiteral
        case LessThan(If(c1,
                         Literal(1, _),
                         If(c2,
                            Literal(-1, _),
                            Literal(0, _))),
                      Literal(0, _)) => simplifyExpr(And(Not(c1), c2))
        case LessThanOrEqual(If(c1,
                                Literal(1, _),
                                If(c2,
                                   Literal(-1, _),
                                   Literal(0, _))),
                             Literal(0, _)) => simplifyExpr(Not(c1))
        case GreaterThan(If(c1,
                            Literal(1, _),
                            If(c2,
                               Literal(-1, _),
                               Literal(0, _))),
                         Literal(0, _)) => c1
        case GreaterThanOrEqual(If(c1,
                                   Literal(1, _),
                                   If(c2,
                                      Literal(-1, _),
                                      Literal(0, _))),
                                Literal(0, _)) => simplifyExpr(Or(c1, Not(c2)))
        case EqualTo(If(c1,
                        Literal(1, _),
                        If(c2,
                           Literal(-1, _),
                           Literal(0, _))),
                     Literal(0, _)) => simplifyExpr(And(Not(c1), Not(c2)))
        case If(c, t, f) if t == f => t
        case _ => expr
      }
    }
    val simplifiedExpr = simplifyExpr(expr)
    if (simplifiedExpr == expr) simplifiedExpr else simplify(simplifiedExpr)
  }

  //
  // State
  //
  case class State(
      val locals: Array[Expression],
      val stack: List[Expression] = List(),
      val cond: Expression = Literal.TrueLiteral,
      val expr: Option[Expression] = None) {
    def +(that: Option[State]): State = {
      that match {
        case Some(s) => addConditional(s)
        case None => this
      }
    }

    private def addConditional(that: State): State = {
      val combine: ((Expression, Expression)) =>
          Expression = { case (l1, l2) => simplify(If(cond, l1, l2)) }
      that.copy(locals = locals.zip(that.locals).map(combine),
                stack = stack.zip(that.stack).map(combine),
                cond = simplify(Or(that.cond, cond)))
    }
  }
  object State {
    def apply(
        lambdaReflection: LambdaReflection,
        children: Seq[Expression]): State = {
      val max = lambdaReflection.getMaxLocals
      val params = lambdaReflection.getParameters.view.zip(children)
      val (locals, _) = ((new Array[Expression](max), 0) /: params) { (l, p) =>
        val (locals, index) = l
        val (param, arg) = p
        val newIndex = param.getKind match {
          case JavaKind.Double => index + 2
          case JavaKind.Long => index + 2
          case _ => index + 1
        }
        (locals.updated(index, arg), newIndex)
      }
      State(locals)
    }
  }

  //
  // CFG
  //
  case class Instruction(val opcode: Opcode, operands: Array[Byte]) {
    def apply(basicBlock: BB, state: State): State = {
      opcode match {
        case Opcode.ALOAD_0 | Opcode.DLOAD_0 | Opcode.FLOAD_0 |
             Opcode.ILOAD_0 | Opcode.LLOAD_0 => load(state, 0)
        case Opcode.ALOAD_1 | Opcode.DLOAD_1 | Opcode.FLOAD_1 |
             Opcode.ILOAD_1 | Opcode.LLOAD_1 => load(state, 1)
        case Opcode.ALOAD_2 | Opcode.DLOAD_2 | Opcode.FLOAD_2 |
             Opcode.ILOAD_2 | Opcode.LLOAD_2 => load(state, 2)
        case Opcode.ALOAD_3 | Opcode.DLOAD_3 | Opcode.FLOAD_3 |
             Opcode.ILOAD_3 | Opcode.LLOAD_3 => load(state, 3)
        case Opcode.ASTORE_0 | Opcode.DSTORE_0 | Opcode.FSTORE_0 |
             Opcode.ISTORE_0 | Opcode.LSTORE_0 => store(state, 0)
        case Opcode.ASTORE_1 | Opcode.DSTORE_1 | Opcode.FSTORE_1 |
             Opcode.ISTORE_1 | Opcode.LSTORE_1 => store(state, 1)
        case Opcode.ASTORE_2 | Opcode.DSTORE_2 | Opcode.FSTORE_2 |
             Opcode.ISTORE_2 | Opcode.LSTORE_2 => store(state, 2)
        case Opcode.ASTORE_3 | Opcode.DSTORE_3 | Opcode.FSTORE_3 |
             Opcode.ISTORE_3 | Opcode.LSTORE_3 => store(state, 3)
        case Opcode.DCMPL => dcmp(state)
        case Opcode.DCMPG => dcmp(state)
        case Opcode.LDC => ldc(state)
        case Opcode.LDC2_W => ldc(state)
        case Opcode.GETSTATIC => getstatic(state)
        case Opcode.ICONST_1 => const(state, 1)
        case Opcode.DCONST_0 => const(state, 0.0)
        case Opcode.DCONST_1 => const(state, 1.0)
        case Opcode.IADD => add(state)
        case Opcode.DADD => add(state)
        case Opcode.ISUB => sub(state)
        case Opcode.IRETURN | Opcode.LRETURN | Opcode.FRETURN | Opcode.DRETURN |
             Opcode.ARETURN | Opcode.RETURN =>
          state.copy(expr = Some(state.stack.head))
        // Branching instructions
        case Opcode.IFLT => ifOp(state, x => simplify(LessThan(x, Literal(0))))
        case Opcode.IFLE => ifOp(state, x => simplify(LessThanOrEqual(x, Literal(0))))
        case Opcode.IFGT => ifOp(state, x => simplify(GreaterThan(x, Literal(0))))
        case Opcode.IFGE => ifOp(state, x => simplify(GreaterThanOrEqual(x, Literal(0))))
        case Opcode.IFEQ => ifOp(state, x => simplify(EqualTo(x, Literal(0))))
        case Opcode.GOTO => state
        case Opcode.INVOKEVIRTUAL => invokevirtual(state)
        case _ => throw new SparkException("Unsupported instruction: " + opcode)
      }
    }

    def size: Int = Instruction.size(opcode)

    def isReturn: Boolean = opcode match {
      case Opcode.IRETURN | Opcode.LRETURN | Opcode.FRETURN | Opcode.DRETURN |
           Opcode.ARETURN | Opcode.RETURN => true
      case _ => false
    }

    //
    // Handle instructions
    //
    private def load(state: State, localsIndex: Int): State = {
      val State(locals, stack, cond, expr) = state
      State(locals, locals(localsIndex)::stack, cond, expr)
    }

    private def store(state: State, localsIndex: Int): State = {
      val State(locals, top::rest, cond, expr) = state
      State(locals.updated(localsIndex, top), rest, cond, expr)
    }

    private def const(state: State, value: Any): State = {
      val State(locals, stack, cond, expr) = state
      State(locals, Literal(value)::stack, cond, expr)
    }

    private def add(state: State): State = {
      val State(locals, op2::op1::rest, cond, expr) = state
      State(locals, Add(op1, op2)::rest, cond, expr)
    }

    private def sub(state: State): State = {
      val State(locals, op2::op1::rest, cond, expr) = state
      State(locals, Subtract(op1, op2)::rest, cond, expr)
    }

    private def ldc(state: State): State = {
      val State(locals, stack, cond, expr) = state
      val constPoolIndex = bytesToInt(operands)
      val constant = Literal(lambdaReflection.lookupConstant(constPoolIndex))
      State(locals, constant::stack, cond, expr)
    }

    private def getstatic(state: State): State = {
      val State(locals, stack, cond, expr) = state
      val constPoolIndex = bytesToInt(operands)
      val field = lambdaReflection.lookupField(constPoolIndex, opcode)
      State(locals, Literal(field.getName)::stack, cond, expr)
    }

    private def dcmp(state: State): State = {
      val State(locals, op2::op1::rest, cond, expr) = state
      val conditional =
        If(GreaterThan(op1, op2),
           Literal(1),
           If(LessThan(op1, op2),
              Literal(-1),
              Literal(0)))
      State(locals, conditional::rest, cond, expr)
    }

    private def ifOp(
        state: State,
        predicate: Expression => Expression): State = {
      val State(locals, top::rest, cond, expr) = state
      State(locals, rest, And(cond, predicate(top)), expr)
    }

    private def gotoOp(state: State): State = state

    private def invokevirtual(state: State): State = {
      val State(locals, stack, cond, expr) = state
      val constPoolIndex = bytesToInt(operands)
      val method = lambdaReflection.lookupMethod(constPoolIndex, opcode)
      val signature = method.getSignature
      val (args, rest) = stack.splitAt(signature.getParameterCount(true))
      if (method.getDeclaringClass.toClassName.equals("scala.math.package$")) {
        // Math functions
        val ret = method.getName match {
          case "asin" => Asin(args(0))
          case "acos" => Acos(args(0))
          case _ => throw new SparkException(
            "Unsupported math function: " + method.getName)
        }
        State(locals, ret::rest, cond, expr)
      } else {
        // Other functions
        throw new SparkException(
          "Unsupported instruction: " + Opcode.INVOKEVIRTUAL)
      }
    }
  }
  object Instruction {
    def size(opcode: Opcode) : Int = {
      opcode match {
        case Opcode.GOTO | Opcode.LDC2_W | Opcode.IFEQ | Opcode.IFNE |
             Opcode.IFLT | Opcode.IFGE | Opcode.IFGT | Opcode.IFLE |
             Opcode.INVOKESTATIC | Opcode.INVOKEVIRTUAL |
             Opcode.GETSTATIC => 3
        case Opcode.LDC => 2
        case Opcode.INVOKEINTERFACE => 5
        case _ => 1
      }
    }
  }

  case class BB(instructionTable: SortedMap[Int, Instruction]) {
    def offset: Int = instructionTable.head._1

    def last: (Int, Instruction) = instructionTable.last

    def lastInstruction: Instruction = last._2

    def propagateCond(states: Map[BB, State]): Map[BB, State] = {
      val state@State(_, _, cond, _) = states(this)
      last._2.opcode match {
        case Opcode.IFLT | Opcode.IFLE | Opcode.IFGT | Opcode.IFGE |
             Opcode.IFEQ => {
          val falseSucc::trueSucc::Nil = cfg.succ(this)
          val falseState = state.copy(cond = simplify(cond match {
            case And(cond1, cond2) => And(cond1, Not(cond2))
            case _ => Not(cond)
          }))
          val trueState = state.copy(cond = simplify(cond))
          (states
            + (falseSucc -> (falseState + states.get(falseSucc)))
            + (trueSucc -> (trueState + states.get(trueSucc))))
        }
        case Opcode.IRETURN | Opcode.LRETURN | Opcode.FRETURN | Opcode.DRETURN |
             Opcode.ARETURN | Opcode.RETURN => states
        case _ =>
          val succ::Nil = cfg.succ(this)
          (states + (succ -> (state + states.get(succ))))
      }
    }
  }

  case class CFG(
    basicBlocks: List[BB],
    pred: Map[BB, List[BB]],
    succ: Map[BB, List[BB]])
  object CFG {
    def apply(lambdaReflection: LambdaReflection): CFG = {
      val code = lambdaReflection.getCode
      val (labels, edges) = collectLabelsAndEdges(code)
      val instructionTable = createInstructionTable(code)
      val (basicBlocks, offsetToBB) = createBasicBlocks(labels,
                                                        instructionTable)
      val (pred, succ) = connectBasicBlocks(basicBlocks, offsetToBB, edges)
      CFG(basicBlocks, pred, succ)
    }

    @tailrec
    private def collectLabelsAndEdges(
        code: Array[Byte],
        offset: Int = 0,
        labels: SortedSet[Int] = SortedSet(),
        edges: SortedMap[Int, List[Int]] = SortedMap())
        : (SortedSet[Int], SortedMap[Int, List[Int]]) = {
      if (offset < code.length) {
        val opcode = Opcode.get(byteToUnsigned(code(offset)))
        val nextOffset = offset + Instruction.size(opcode)
        opcode match {
          case Opcode.IFEQ | Opcode.IFNE | Opcode.IFLT | Opcode.IFGE |
               Opcode.IFGT | Opcode.IFLE => {
            val falseOffset = nextOffset
            val trueOffset = offset + bytesToInt(Array(code(offset + 1),
                                                       code(offset + 2)))
            collectLabelsAndEdges(
              code, nextOffset,
              labels + falseOffset + trueOffset,
              edges + (offset -> List(falseOffset, trueOffset)))
          }
          case Opcode.GOTO =>
            val labelOffset = offset + bytesToInt(Array(code(offset + 1),
                                                        code(offset + 2)))
            collectLabelsAndEdges(
              code, nextOffset,
              labels + labelOffset,
              edges + (offset -> List(labelOffset)))
          case _ => collectLabelsAndEdges(code, nextOffset, labels, edges)
        }
      } else {
        (labels, edges)
      }
    }

    @tailrec
    private def createInstructionTable(
        code: Array[Byte],
        offset: Int = 0,
        instructionTable: SortedMap[Int, Instruction] = SortedMap())
        : SortedMap[Int, Instruction] = {
      if (offset < code.length) {
        val opcode = Opcode.get(byteToUnsigned(code(offset)))
        val nextOffset = offset + Instruction.size(opcode)
        val instruction = Instruction(opcode,
                                      code.slice(offset + 1, nextOffset))
        createInstructionTable(code, nextOffset,
                               instructionTable + (offset -> instruction))
      } else {
        instructionTable
      }
    }

    @tailrec
    private def createBasicBlocks(
        labels: SortedSet[Int],
        instructionTable: SortedMap[Int, Instruction],
        basicBlocks: List[BB] = List(),
        offsetToBB: IntMap[BB] = IntMap()): (List[BB], IntMap[BB]) = {
      if (labels.isEmpty) {
        val instructions = instructionTable
        val bb = BB(instructions)
        ((bb+:basicBlocks).reverse,
         (offsetToBB /: instructions) { case (offsetToBB, (offset, _)) =>
           offsetToBB + (offset -> bb)
         })
      } else {
        val (instructions, rest) = instructionTable.span(_._1 < labels.head)
        val bb = BB(instructions)
        createBasicBlocks(
          labels.tail, rest, bb+:basicBlocks,
          (offsetToBB /: instructions) { case (offsetToBB, (offset, _)) =>
            offsetToBB + (offset -> bb)
          })
      }
    }

    @tailrec
    private def connectBasicBlocks(
        basicBlocks: List[BB],
        offsetToBB: IntMap[BB],
        edges: SortedMap[Int, List[Int]],
        pred: Map[BB, List[BB]] = Map().withDefaultValue(Nil),
        succ: Map[BB, List[BB]] = Map().withDefaultValue(Nil))
        : (Map[BB, List[BB]], Map[BB, List[BB]]) = {
      if (basicBlocks.isEmpty) {
        (pred, succ)
      } else {
        val src::rest = basicBlocks
        val dst = edges.getOrElse(src.last._1,
                                  if (rest.isEmpty) {
                                    List()
                                  } else {
                                    List(rest.head.offset)
                                  }).map(offsetToBB)
        connectBasicBlocks(
          rest,
          offsetToBB,
          edges,
          (pred /: dst) { (p, l) => (p + (l -> (src::p(l)))) },
          succ + (src -> dst))
      }
    }

  }

  //
  // JVMCI
  //
  case class LambdaReflection(private val anonfun: HotSpotResolvedJavaMethod) {
    def lookupConstant(constPoolIndex: Int): Any = {
      val constant = anonfun.getConstantPool.lookupConstant(constPoolIndex)
      if (constant.isInstanceOf[PrimitiveConstant]) {
        constant.asInstanceOf[PrimitiveConstant].asBoxedPrimitive
      } else if (constant.isInstanceOf[HotSpotObjectConstant]) {
        val objectConstant = constant.asInstanceOf[HotSpotObjectConstant]
        if (objectConstant.isInternedString) {
          objectConstant.asObject(classOf[String])
        } else {
          throw new SparkException(
            "Unsupported object constant: " + objectConstant)
        }
      } else {
        throw new SparkException("Unsupported constant: " + constant)
      }
    }

    def lookupField(constPoolIndex: Int, opcode: Opcode): jdk.vm.ci.meta.JavaField = {
      anonfun.getConstantPool.lookupField(constPoolIndex, anonfun, opcode.opcode)
    }

    def lookupMethod(constPoolIndex: Int, opcode: Opcode): jdk.vm.ci.meta.JavaMethod = {
      anonfun.getConstantPool.lookupMethod(constPoolIndex, opcode.opcode)
    }
    // scalastyle:off
    def getCode = anonfun.getCode

    def getParameters = anonfun.getParameters

    def getMaxLocals = anonfun.getMaxLocals
    // scalastyle:on
  }
  object LambdaReflection {
    def apply(function: AnyRef): LambdaReflection = {
      val functionClass = function.getClass
      val applyMethod = functionClass.getMethods.find { x =>
        x.getName.equals("apply") && x.getReturnType == classOf[Any]
      }.get
      LambdaReflection(getAnonfun(applyMethod, functionClass))
    }

    @tailrec
    private def getAnonfun(
        method: Method,
        lambdaClass: Class[_]): HotSpotResolvedJavaMethod = {
      val hsmap = HotSpotJVMCIRuntime.runtime.getHostJVMCIBackend.getMetaAccess
      val name = method.getName
      val hsMethod = hsmap.lookupJavaMethod(method)
                          .asInstanceOf[HotSpotResolvedJavaMethod]
      if (name.startsWith("$anonfun$") && !name.endsWith("adapted")) {
        hsMethod
      } else {
        getAnonfun(
          getTarget(
            lambdaClass,
            (x: Int) => byteToUnsigned(hsMethod.getCode()(x)),
            hsMethod.getConstantPool,
            0),
          lambdaClass)
      }
    }

    @tailrec
    private def getTarget(
        lambdaClass: Class[_],
        getByte: Int => Int,
        constantPool: ConstantPool,
        offset: Int): Method = {
      val opcode = Opcode.get(getByte(offset))
      opcode match {
        case Opcode.INVOKESTATIC |
             Opcode.INVOKEINTERFACE |
             Opcode.INVOKEVIRTUAL => {
          val constPoolIndex = (getByte(offset + 1) << 8) | getByte(offset + 2)
          val hsMethod = constantPool.lookupMethod(constPoolIndex,
                                                   opcode.opcode)
          val targetName = hsMethod.getName
          if (targetName.startsWith("$anonfun$")) {
            val declaringClassName = hsMethod.getDeclaringClass.toJavaName
            // scalastyle:off classforname
            Class.forName(declaringClassName, true, lambdaClass.getClassLoader)
                 .getMethods.find(_.getName.equals(targetName))
                 .get
            // scalastyle:on classforname
          } else if (targetName.startsWith("apply")) {
            lambdaClass.getMethods.find(_.getName.equals(targetName)).get
          } else {
            getTarget(lambdaClass, getByte, constantPool,
                      offset + Instruction.size(opcode))
          }
        }
        case _ => getTarget(lambdaClass, getByte, constantPool,
                            offset + Instruction.size(opcode))
      }
    }
  }

  //
  // Helper functions
  //
  private def byteToUnsigned(byte: Byte): Int = {
    byte & 0xff
  }
  private def bytesToInt(bytes: Array[Byte]): Int = {
    (byteToUnsigned(bytes.head) /: bytes.tail) { (i, b) =>
      (i << 8) | byteToUnsigned(b)
    }
  }
}
