/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.sql.catalyst.expressions

import org.apache.spark.SparkException
import org.apache.spark.sql.catalyst.{CatalystTypeConverters, InternalRow, ScalaReflection}
import org.apache.spark.sql.catalyst.expressions.codegen._
import org.apache.spark.sql.catalyst.expressions.codegen.Block._
import org.apache.spark.sql.types.{AbstractDataType, DataType}

/**
 * User-defined function.
 * @param function  The user defined scala function to run.
 *                  Note that if you use primitive parameters, you are not able to check if it is
 *                  null or not, and the UDF will return null for you if the primitive input is
 *                  null. Use boxed type or [[Option]] if you wanna do the null-handling yourself.
 * @param dataType  Return type of function.
 * @param children  The input expressions of this UDF.
 * @param inputPrimitives The analyzer should be aware of Scala primitive types so as to make the
 *                        UDF return null if there is any null input value of these types. On the
 *                        other hand, Java UDFs can only have boxed types, thus this parameter will
 *                        always be all false.
 * @param inputTypes  The expected input types of this UDF, used to perform type coercion. If we do
 *                    not want to perform coercion, simply use "Nil". Note that it would've been
 *                    better to use Option of Seq[DataType] so we can use "None" as the case for no
 *                    type coercion. However, that would require more refactoring of the codebase.
 * @param udfName  The user-specified name of this UDF.
 * @param nullable  True if the UDF can return null value.
 * @param udfDeterministic  True if the UDF is deterministic. Deterministic UDF returns same result
 *                          each time it is invoked with a particular input.
 */
case class ScalaUDF(
    function: AnyRef,
    dataType: DataType,
    children: Seq[Expression],
    inputPrimitives: Seq[Boolean],
    inputTypes: Seq[AbstractDataType] = Nil,
    udfName: Option[String] = None,
    nullable: Boolean = true,
    udfDeterministic: Boolean = true)
  extends Expression with NonSQLExpression with UserDefinedExpression {

  override lazy val deterministic: Boolean = udfDeterministic && children.forall(_.deterministic)

  override def toString: String = s"${udfName.getOrElse("UDF")}(${children.mkString(", ")})"

  // scalastyle:off line.size.limit

  /** This method has been generated by this script

    (1 to 22).map { x =>
      val anys = (1 to x).map(x => "Any").reduce(_ + ", " + _)
      val childs = (0 to x - 1).map(x => s"val child$x = children($x)").reduce(_ + "\n  " + _)
      val converters = (0 to x - 1).map(x => s"lazy val converter$x = CatalystTypeConverters.createToScalaConverter(child$x.dataType)").reduce(_ + "\n  " + _)
      val evals = (0 to x - 1).map(x => s"converter$x(child$x.eval(input))").reduce(_ + ",\n      " + _)

      s"""case $x =>
      val func = function.asInstanceOf[($anys) => Any]
      $childs
      $converters
      (input: InternalRow) => {
        func(
          $evals)
      }
      """
    }.foreach(println)

  */
  private[this] val f = children.size match {
    case 0 =>
      val func = function.asInstanceOf[() => Any]
      (input: InternalRow) => {
        func()
      }

    case 1 =>
      val func = function.asInstanceOf[(Any) => Any]
      val child0 = children(0)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)))
      }

    case 2 =>
      val func = function.asInstanceOf[(Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)))
      }

    case 3 =>
      val func = function.asInstanceOf[(Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)))
      }

    case 4 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)))
      }

    case 5 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)))
      }

    case 6 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)))
      }

    case 7 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)))
      }

    case 8 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)))
      }

    case 9 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)))
      }

    case 10 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)))
      }

    case 11 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)))
      }

    case 12 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)))
      }

    case 13 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)))
      }

    case 14 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)))
      }

    case 15 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)))
      }

    case 16 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)))
      }

    case 17 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)))
      }

    case 18 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)))
      }

    case 19 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)))
      }

    case 20 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      val child19 = children(19)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      lazy val converter19 = CatalystTypeConverters.createToScalaConverter(child19.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)),
          converter19(child19.eval(input)))
      }

    case 21 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      val child19 = children(19)
      val child20 = children(20)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      lazy val converter19 = CatalystTypeConverters.createToScalaConverter(child19.dataType)
      lazy val converter20 = CatalystTypeConverters.createToScalaConverter(child20.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)),
          converter19(child19.eval(input)),
          converter20(child20.eval(input)))
      }

    case 22 =>
      val func = function.asInstanceOf[(Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any, Any) => Any]
      val child0 = children(0)
      val child1 = children(1)
      val child2 = children(2)
      val child3 = children(3)
      val child4 = children(4)
      val child5 = children(5)
      val child6 = children(6)
      val child7 = children(7)
      val child8 = children(8)
      val child9 = children(9)
      val child10 = children(10)
      val child11 = children(11)
      val child12 = children(12)
      val child13 = children(13)
      val child14 = children(14)
      val child15 = children(15)
      val child16 = children(16)
      val child17 = children(17)
      val child18 = children(18)
      val child19 = children(19)
      val child20 = children(20)
      val child21 = children(21)
      lazy val converter0 = CatalystTypeConverters.createToScalaConverter(child0.dataType)
      lazy val converter1 = CatalystTypeConverters.createToScalaConverter(child1.dataType)
      lazy val converter2 = CatalystTypeConverters.createToScalaConverter(child2.dataType)
      lazy val converter3 = CatalystTypeConverters.createToScalaConverter(child3.dataType)
      lazy val converter4 = CatalystTypeConverters.createToScalaConverter(child4.dataType)
      lazy val converter5 = CatalystTypeConverters.createToScalaConverter(child5.dataType)
      lazy val converter6 = CatalystTypeConverters.createToScalaConverter(child6.dataType)
      lazy val converter7 = CatalystTypeConverters.createToScalaConverter(child7.dataType)
      lazy val converter8 = CatalystTypeConverters.createToScalaConverter(child8.dataType)
      lazy val converter9 = CatalystTypeConverters.createToScalaConverter(child9.dataType)
      lazy val converter10 = CatalystTypeConverters.createToScalaConverter(child10.dataType)
      lazy val converter11 = CatalystTypeConverters.createToScalaConverter(child11.dataType)
      lazy val converter12 = CatalystTypeConverters.createToScalaConverter(child12.dataType)
      lazy val converter13 = CatalystTypeConverters.createToScalaConverter(child13.dataType)
      lazy val converter14 = CatalystTypeConverters.createToScalaConverter(child14.dataType)
      lazy val converter15 = CatalystTypeConverters.createToScalaConverter(child15.dataType)
      lazy val converter16 = CatalystTypeConverters.createToScalaConverter(child16.dataType)
      lazy val converter17 = CatalystTypeConverters.createToScalaConverter(child17.dataType)
      lazy val converter18 = CatalystTypeConverters.createToScalaConverter(child18.dataType)
      lazy val converter19 = CatalystTypeConverters.createToScalaConverter(child19.dataType)
      lazy val converter20 = CatalystTypeConverters.createToScalaConverter(child20.dataType)
      lazy val converter21 = CatalystTypeConverters.createToScalaConverter(child21.dataType)
      (input: InternalRow) => {
        func(
          converter0(child0.eval(input)),
          converter1(child1.eval(input)),
          converter2(child2.eval(input)),
          converter3(child3.eval(input)),
          converter4(child4.eval(input)),
          converter5(child5.eval(input)),
          converter6(child6.eval(input)),
          converter7(child7.eval(input)),
          converter8(child8.eval(input)),
          converter9(child9.eval(input)),
          converter10(child10.eval(input)),
          converter11(child11.eval(input)),
          converter12(child12.eval(input)),
          converter13(child13.eval(input)),
          converter14(child14.eval(input)),
          converter15(child15.eval(input)),
          converter16(child16.eval(input)),
          converter17(child17.eval(input)),
          converter18(child18.eval(input)),
          converter19(child19.eval(input)),
          converter20(child20.eval(input)),
          converter21(child21.eval(input)))
      }
  }

  // scalastyle:on line.size.limit
  override def doGenCode(
      ctx: CodegenContext,
      ev: ExprCode): ExprCode = {
    val converterClassName = classOf[Any => Any].getName

    // The type converters for inputs and the result.
    val converters: Array[Any => Any] = children.map { c =>
      CatalystTypeConverters.createToScalaConverter(c.dataType)
    }.toArray :+ CatalystTypeConverters.createToCatalystConverter(dataType)
    val convertersTerm = ctx.addReferenceObj("converters", converters, s"$converterClassName[]")
    val errorMsgTerm = ctx.addReferenceObj("errMsg", udfErrorMessage)
    val resultTerm = ctx.freshName("result")

    // codegen for children expressions
    val evals = children.map(_.genCode(ctx))

    // Generate the codes for expressions and calling user-defined function
    // We need to get the boxedType of dataType's javaType here. Because for the dataType
    // such as IntegerType, its javaType is `int` and the returned type of user-defined
    // function is Object. Trying to convert an Object to `int` will cause casting exception.
    val evalCode = evals.map(_.code).mkString("\n")
    val (funcArgs, initArgs) = evals.zipWithIndex.zip(children.map(_.dataType)).map {
      case ((eval, i), dt) =>
        val argTerm = ctx.freshName("arg")
        val initArg = if (CatalystTypeConverters.isPrimitive(dt)) {
          val convertedTerm = ctx.freshName("conv")
          s"""
             |${CodeGenerator.boxedType(dt)} $convertedTerm = ${eval.value};
             |Object $argTerm = ${eval.isNull} ? null : $convertedTerm;
           """.stripMargin
        } else {
          s"Object $argTerm = ${eval.isNull} ? null : $convertersTerm[$i].apply(${eval.value});"
        }
        (argTerm, initArg)
    }.unzip

    val udf = ctx.addReferenceObj("udf", function, s"scala.Function${children.length}")
    val getFuncResult = s"$udf.apply(${funcArgs.mkString(", ")})"
    val resultConverter = s"$convertersTerm[${children.length}]"
    val boxedType = CodeGenerator.boxedType(dataType)

    val funcInvokation = if (CatalystTypeConverters.isPrimitive(dataType)
        // If the output is nullable, the returned value must be unwrapped from the Option
        && !nullable) {
      s"$resultTerm = ($boxedType)$getFuncResult"
    } else {
      s"$resultTerm = ($boxedType)$resultConverter.apply($getFuncResult)"
    }
    val callFunc =
      s"""
         |$boxedType $resultTerm = null;
         |try {
         |  $funcInvokation;
         |} catch (Exception e) {
         |  throw new org.apache.spark.SparkException($errorMsgTerm, e);
         |}
       """.stripMargin

    ev.copy(code =
      code"""
         |$evalCode
         |${initArgs.mkString("\n")}
         |$callFunc
         |
         |boolean ${ev.isNull} = $resultTerm == null;
         |${CodeGenerator.javaType(dataType)} ${ev.value} = ${CodeGenerator.defaultValue(dataType)};
         |if (!${ev.isNull}) {
         |  ${ev.value} = $resultTerm;
         |}
       """.stripMargin)
  }

  private[this] val resultConverter = CatalystTypeConverters.createToCatalystConverter(dataType)

  lazy val udfErrorMessage = {
    val funcCls = function.getClass.getSimpleName
    val inputTypes = children.map(_.dataType.catalogString).mkString(", ")
    val outputType = dataType.catalogString
    s"Failed to execute user defined function($funcCls: ($inputTypes) => $outputType)"
  }

  override def eval(input: InternalRow): Any = {
    val result = try {
      f(input)
    } catch {
      case e: Exception =>
        throw new SparkException(udfErrorMessage, e)
    }

    resultConverter(result)
  }

  val expr = {
    try {
      CatalystExpressionBuilder(function)(children)
    } catch {
      case e: SparkException =>
        // scalastyle:off println
        System.err.println("UDF compilation failure: " + e)
        None
        // scalastyle:on println
    }
  }
}

case class CatalystExpressionBuilder(private val function: AnyRef) {

  import java.lang.invoke.SerializedLambda
  import javassist.ClassClassPath
  import javassist.ClassPool
  import javassist.CtClass
  import javassist.CtField
  import javassist.CtMethod
  import javassist.bytecode.CodeIterator
  import javassist.bytecode.ConstPool
  import javassist.bytecode.Descriptor
  import javassist.bytecode.Opcode
  import org.apache.spark.sql.types._
  import org.apache.spark.util.Utils.classForName
  import scala.annotation.tailrec
  import scala.collection.immutable.IntMap
  import scala.collection.immutable.SortedMap
  import scala.collection.immutable.SortedSet

  final private val lambdaReflection = LambdaReflection(function)
  final private val cfg = CFG(lambdaReflection)

  def apply(children: Seq[Expression]): Option[Expression] = {
    val entryState = State(lambdaReflection, children)
    val entryBlock = cfg.basicBlocks.head
    apply(List(entryBlock), Map(entryBlock -> entryState))
  }

  @tailrec
  private def apply(
      worklist: List[BB],
      states: Map[BB, State],
      pending: Map[BB, Int] = cfg.pred.mapValues { v => v.size },
      visited: Set[BB] = Set()): Option[Expression] = {
    val basicBlock::rest = worklist
    val state = states(basicBlock)
    val newState = basicBlock.instructionTable.foldLeft(state) { (st, i) =>
      i._2(basicBlock, st)
    }
    val newStates = basicBlock.propagateCond(states + (basicBlock -> newState))
    if (basicBlock.lastInstruction.isReturn) {
      newStates(basicBlock).expr
    } else {
      val newVisited = visited + basicBlock
      val (readySucc, newPending) =
        cfg.succ(basicBlock).foldLeft((List[BB](), pending)) { case (x@(r, np), s) =>
          if (newVisited(s)) {
            x
          } else {
            val count = np(s) - 1
            if (count > 0) (r, np + (s -> count)) else (s::r, np - s)
          }
        }
      apply(
        readySucc:::rest,
        newStates,
        newPending,
        newVisited)
    }
  }

  @tailrec
  private def simplify(expr: Expression): Expression = {
    def simplifyExpr(expr: Expression): Expression = {
      expr match {
        case And(Literal.TrueLiteral, c) => simplifyExpr(c)
        case And(c, Literal.TrueLiteral) => simplifyExpr(c)
        case And(Literal.FalseLiteral, c) => Literal.FalseLiteral
        case And(c1@LessThan(s1, Literal(v1, t1)),
                 c2@LessThan(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                   t1 match {
                     case DoubleType =>
                       if (v1.asInstanceOf[Double] < v2.asInstanceOf[Double]) {
                         c1
                       } else {
                         c2
                       }
                     case _ => expr
                   }
                 }
        case And(c1@LessThanOrEqual(s1, Literal(v1, t1)),
                 c2@LessThanOrEqual(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                   t1 match {
                     case DoubleType =>
                       if (v1.asInstanceOf[Double] < v2.asInstanceOf[Double]) {
                         c1
                       } else {
                         c2
                       }
                     case _ => expr
                   }
                 }
        case And(c1@LessThanOrEqual(s1, Literal(v1, t1)),
                 c2@LessThan(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                   t1 match {
                     case DoubleType =>
                       if (v1.asInstanceOf[Double] < v2.asInstanceOf[Double]) {
                         c1
                       } else {
                         c2
                       }
                     case _ => expr
                   }
                 }
        case And(c1@GreaterThan(s1, Literal(v1, t1)),
                 c2@GreaterThan(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                   t1 match {
                     case DoubleType =>
                       if (v1.asInstanceOf[Double] > v2.asInstanceOf[Double]) {
                         c1
                       } else {
                         c2
                       }
                     case _ => expr
                   }
                 }
        case And(c1@GreaterThan(s1, Literal(v1, t1)),
                 c2@GreaterThanOrEqual(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                   t1 match {
                     case DoubleType =>
                       if (v1.asInstanceOf[Double] >= v2.asInstanceOf[Double]) {
                         c1
                       } else {
                         c2
                       }
                     case _ => expr
                   }
                 }
        case And(c1, c2) => And(simplifyExpr(c1), simplifyExpr(c2))
        case Or(Literal.TrueLiteral, c) => Literal.TrueLiteral
        case Or(Literal.FalseLiteral, c) => simplifyExpr(c)
        case Or(c, Literal.FalseLiteral) => simplifyExpr(c)
        case Or(c1@GreaterThan(s1, Literal(v1, t1)),
                c2@GreaterThanOrEqual(s2, Literal(v2, t2))) if s1 == s2 && t1 == t2 => {
                  t1 match {
                    case DoubleType =>
                      if (v1.asInstanceOf[Double] < v2.asInstanceOf[Double]) {
                        c1
                      } else {
                        c2
                      }
                    case _ =>
                      expr
                  }
                }
        case Or(c1, c2) => Or(simplifyExpr(c1), simplifyExpr(c2))
        case Not(Literal.TrueLiteral) => Literal.FalseLiteral
        case Not(Literal.FalseLiteral) => Literal.TrueLiteral
        case Not(LessThan(c1, c2)) => GreaterThanOrEqual(c1, c2)
        case Not(LessThanOrEqual(c1, c2)) => GreaterThan(c1, c2)
        case Not(GreaterThan(c1, c2)) => LessThanOrEqual(c1, c2)
        case Not(GreaterThanOrEqual(c1, c2)) => LessThan(c1, c2)
        case EqualTo(Literal(v1, _), Literal(v2, _)) =>
          if (v1 == v2) Literal.TrueLiteral else Literal.FalseLiteral
        case LessThan(If(c1,
                         Literal(1, _),
                         If(c2,
                            Literal(-1, _),
                            Literal(0, _))),
                      Literal(0, _)) => simplifyExpr(And(Not(c1), c2))
        case LessThanOrEqual(If(c1,
                                Literal(1, _),
                                If(c2,
                                   Literal(-1, _),
                                   Literal(0, _))),
                             Literal(0, _)) => simplifyExpr(Not(c1))
        case GreaterThan(If(c1,
                            Literal(1, _),
                            If(c2,
                               Literal(-1, _),
                               Literal(0, _))),
                         Literal(0, _)) => c1
        case GreaterThanOrEqual(If(c1,
                                   Literal(1, _),
                                   If(c2,
                                      Literal(-1, _),
                                      Literal(0, _))),
                                Literal(0, _)) => simplifyExpr(Or(c1, Not(c2)))
        case EqualTo(If(c1,
                        Literal(1, _),
                        If(c2,
                           Literal(-1, _),
                           Literal(0, _))),
                     Literal(0, _)) => simplifyExpr(And(Not(c1), Not(c2)))
        case If(c, t, f) if t == f => t
        case _ => expr
      }
    }
    val simplifiedExpr = simplifyExpr(expr)
    if (simplifiedExpr == expr) simplifiedExpr else simplify(simplifiedExpr)
  }

  //
  // State
  //
  case class State(
      val locals: Array[Expression],
      val stack: List[Expression] = List(),
      val cond: Expression = Literal.TrueLiteral,
      val expr: Option[Expression] = None) {
    def +(that: Option[State]): State = {
      that match {
        case Some(s) => addConditional(s)
        case None => this
      }
    }

    private def addConditional(that: State): State = {
      val combine: ((Expression, Expression)) =>
          Expression = { case (l1, l2) => simplify(If(cond, l1, l2)) }
      that.copy(locals = locals.zip(that.locals).map(combine),
                stack = stack.zip(that.stack).map(combine),
                cond = simplify(Or(that.cond, cond)))
    }
  }
  object State {
    def apply(
        lambdaReflection: LambdaReflection,
        children: Seq[Expression]): State = {
      val max = lambdaReflection.maxLocals
      val params = lambdaReflection.parameters.view.zip(children)
      val (locals, _) = params.foldLeft((new Array[Expression](max), 0)) { (l, p) =>
        val (locals, index) = l
        val (param, arg) = p
        val newIndex = {
          if (param == CtClass.doubleType || param == CtClass.longType) {
            index + 2
          } else {
            index + 1
          }
        }
        (locals.updated(index, arg), newIndex)
      }
      State(locals)
    }
  }

  //
  // CFG
  //
  case class Instruction(val opcode: Int, operand: Int) {
    def apply(basicBlock: BB, state: State): State = {
      opcode match {
        case Opcode.ALOAD_0 | Opcode.DLOAD_0 | Opcode.FLOAD_0 |
             Opcode.ILOAD_0 | Opcode.LLOAD_0 => load(state, 0)
        case Opcode.ALOAD_1 | Opcode.DLOAD_1 | Opcode.FLOAD_1 |
             Opcode.ILOAD_1 | Opcode.LLOAD_1 => load(state, 1)
        case Opcode.ALOAD_2 | Opcode.DLOAD_2 | Opcode.FLOAD_2 |
             Opcode.ILOAD_2 | Opcode.LLOAD_2 => load(state, 2)
        case Opcode.ALOAD_3 | Opcode.DLOAD_3 | Opcode.FLOAD_3 |
             Opcode.ILOAD_3 | Opcode.LLOAD_3 => load(state, 3)
        case Opcode.ALOAD | Opcode.DLOAD | Opcode.FLOAD |
             Opcode.ILOAD | Opcode.LLOAD => load(state, operand)
        case Opcode.ASTORE_0 | Opcode.DSTORE_0 | Opcode.FSTORE_0 |
             Opcode.ISTORE_0 | Opcode.LSTORE_0 => store(state, 0)
        case Opcode.ASTORE_1 | Opcode.DSTORE_1 | Opcode.FSTORE_1 |
             Opcode.ISTORE_1 | Opcode.LSTORE_1 => store(state, 1)
        case Opcode.ASTORE_2 | Opcode.DSTORE_2 | Opcode.FSTORE_2 |
             Opcode.ISTORE_2 | Opcode.LSTORE_2 => store(state, 2)
        case Opcode.ASTORE_3 | Opcode.DSTORE_3 | Opcode.FSTORE_3 |
             Opcode.ISTORE_3 | Opcode.LSTORE_3 => store(state, 3)
        case Opcode.DCONST_0 | Opcode.DCONST_1 =>
          const(state, (opcode - Opcode.DCONST_0).asInstanceOf[Double])
        case Opcode.FCONST_0 | Opcode.FCONST_1 | Opcode.FCONST_2 =>
          const(state, (opcode - Opcode.FCONST_0).asInstanceOf[Float])
        case Opcode.ICONST_0 | Opcode.ICONST_1 | Opcode.ICONST_2 |
             Opcode.ICONST_3 | Opcode.ICONST_4 | Opcode.ICONST_5 =>
          const(state, (opcode - Opcode.ICONST_0).asInstanceOf[Int])
        case Opcode.LCONST_0 | Opcode.LCONST_1 =>
          const(state, (opcode - Opcode.LCONST_0).asInstanceOf[Long])
        case Opcode.DADD | Opcode.FADD | Opcode.IADD | Opcode.LADD => add(state)
        case Opcode.DSUB | Opcode.FSUB | Opcode.ISUB | Opcode.LSUB => sub(state)
        case Opcode.DMUL | Opcode.FMUL | Opcode.IMUL | Opcode.LMUL => mul(state)
        case Opcode.DCMPL | Opcode.DCMPG => dcmp(state)
        case Opcode.LDC | Opcode.LDC_W | Opcode.LDC2_W => ldc(state)
        case Opcode.DUP => dup(state)
        case Opcode.GETSTATIC => getstatic(state)
        // Cast instructions
        case Opcode.I2B => cast(state, ByteType)
        case Opcode.I2C =>
          throw new SparkException("Opcode.I2C unsupported: no corresponding Catalyst expression")
        case Opcode.F2D | Opcode.I2D | Opcode.L2D => cast(state, DoubleType)
        case Opcode.D2F | Opcode.I2F | Opcode.L2F => cast(state, FloatType)
        case Opcode.D2I | Opcode.F2I | Opcode.L2I => cast(state, IntegerType)
        case Opcode.D2L | Opcode.F2L | Opcode.I2L => cast(state, LongType)
        case Opcode.I2S => cast(state, ShortType)
        // Branching instructions
        case Opcode.IFLT => ifOp(state, x => simplify(LessThan(x, Literal(0))))
        case Opcode.IFLE => ifOp(state, x => simplify(LessThanOrEqual(x, Literal(0))))
        case Opcode.IFGT => ifOp(state, x => simplify(GreaterThan(x, Literal(0))))
        case Opcode.IFGE => ifOp(state, x => simplify(GreaterThanOrEqual(x, Literal(0))))
        case Opcode.IFEQ => ifOp(state, x => simplify(EqualTo(x, Literal(0))))
        case Opcode.IFNE => ifOp(state, x => simplify(Not(EqualTo(x, Literal(0)))))
        case Opcode.IFNULL => ifOp(state, x => simplify(IsNull(x)))
        case Opcode.IFNONNULL => ifOp(state, x => simplify(IsNotNull(x)))
        case Opcode.GOTO => state
        case Opcode.IRETURN | Opcode.LRETURN | Opcode.FRETURN | Opcode.DRETURN |
             Opcode.ARETURN | Opcode.RETURN =>
          state.copy(expr = Some(state.stack.head))
        // Call instructions
        case Opcode.INVOKEVIRTUAL => invokevirtual(state)
        case _ => throw new SparkException("Unsupported instruction: " + opcode)
      }
    }

    def isReturn: Boolean = opcode match {
      case Opcode.IRETURN | Opcode.LRETURN | Opcode.FRETURN | Opcode.DRETURN |
           Opcode.ARETURN | Opcode.RETURN => true
      case _ => false
    }

    //
    // Handle instructions
    //
    private def load(state: State, localsIndex: Int): State = {
      val State(locals, stack, cond, expr) = state
      State(locals, locals(localsIndex)::stack, cond, expr)
    }

    private def store(state: State, localsIndex: Int): State = {
      val State(locals, top::rest, cond, expr) = state
      State(locals.updated(localsIndex, top), rest, cond, expr)
    }

    private def const(state: State, value: Any): State = {
      val State(locals, stack, cond, expr) = state
      State(locals, Literal(value)::stack, cond, expr)
    }

    private def add(state: State): State = {
      val State(locals, op2::op1::rest, cond, expr) = state
      State(locals, Add(op1, op2)::rest, cond, expr)
    }

    private def sub(state: State): State = {
      val State(locals, op2::op1::rest, cond, expr) = state
      State(locals, Subtract(op1, op2)::rest, cond, expr)
    }

    private def mul(state: State): State = {
      val State(locals, op2::op1::rest, cond, expr) = state
      State(locals, Multiply(op1, op2)::rest, cond, expr)
    }

    private def ldc(state: State): State = {
      val State(locals, stack, cond, expr) = state
      val constant = Literal(lambdaReflection.lookupConstant(operand))
      State(locals, constant::stack, cond, expr)
    }

    private def dup(state: State): State = {
      val State(locals, top::rest, cond, expr) = state
      State(locals, top::top::rest, cond, expr)
    }

    private def getstatic(state: State): State = {
      val State(locals, stack, cond, expr) = state
      State(locals, Literal(operand)::stack, cond, expr)
    }

    private def dcmp(state: State): State = {
      val State(locals, op2::op1::rest, cond, expr) = state
      val conditional =
        If(GreaterThan(op1, op2),
           Literal(1),
           If(LessThan(op1, op2),
              Literal(-1),
              Literal(0)))
      State(locals, conditional::rest, cond, expr)
    }

    private def cast(
        state: State,
        dataType: DataType): State = {
      val State(locals, top::rest, cond, expr) = state
      State(locals, Cast(top, dataType)::rest, cond, expr)
    }

    private def ifOp(
        state: State,
        predicate: Expression => Expression): State = {
      val State(locals, top::rest, cond, expr) = state
      State(locals, rest, And(cond, predicate(top)), expr)
    }

    private def gotoOp(state: State): State = state

    private def invokevirtual(state: State): State = {
      val State(locals, stack, cond, expr) = state
      val method = lambdaReflection.lookupMethod(operand)
      val paramTypes = method.getParameterTypes
      val (args, objrefIndex::rest) = stack.splitAt(paramTypes.length)
      val objref = objrefIndex match {
        case Literal(index, IntegerType) =>
          lambdaReflection.lookupField(index.asInstanceOf[Int])
        case _ =>
          throw new SparkException(
            "Unsupported instruction: " + Opcode.INVOKEVIRTUAL)
      }
      if (objref.getType.getName.equals("scala.math.package$")) {
        // Math functions
        val ret = method.getName match {
          case "abs" => Abs(args(0))
          case "acos" => Acos(args(0))
          case "asin" => Asin(args(0))
          case "atan" => Atan(args(0))
          case "cos" => Cos(args(0))
          case "cosh" => Cosh(args(0))
          case "sin" => Sin(args(0))
          case "tan" => Tan(args(0))
          case "tanh" => Tanh(args(0))
          case "ceil" => Ceil(args(0))
          case "floor" => Floor(args(0))
          case "exp" => Exp(args(0))
          case "log" => Log(args(0))
          case "log10" => Log10(args(0))
          case "sqrt" => Sqrt(args(0))
          case _ => throw new SparkException(
            "Unsupported math function: " + method.getName)
        }
        State(locals, ret::rest, cond, expr)
      } else {
        // Other functions
        throw new SparkException(
          "Unsupported instruction: " + Opcode.INVOKEVIRTUAL)
      }
    }
  }
  object Instruction {
    def apply(codeIterator: CodeIterator, offset: Int): Instruction = {
      val opcode = codeIterator.byteAt(offset)
      val operand = opcode match {
        case Opcode.ALOAD | Opcode.DLOAD | Opcode.FLOAD |
             Opcode.ILOAD | Opcode.LLOAD | Opcode.LDC =>
          codeIterator.byteAt(offset + 1)
        case Opcode.LDC_W | Opcode.LDC2_W |
             Opcode.INVOKESTATIC | Opcode.INVOKEVIRTUAL | Opcode.INVOKEINTERFACE |
             Opcode.GETSTATIC =>
          codeIterator.u16bitAt(offset + 1)
        case Opcode.GOTO |
             Opcode.IFEQ | Opcode.IFNE | Opcode.IFLT |
             Opcode.IFGE | Opcode.IFGT | Opcode.IFLE |
             Opcode.IFNULL | Opcode.IFNONNULL =>
          codeIterator.s16bitAt(offset + 1)
        case _ => 0
      }
      Instruction(opcode, operand)
    }
  }

  case class BB(instructionTable: SortedMap[Int, Instruction]) {
    def offset: Int = instructionTable.head._1

    def last: (Int, Instruction) = instructionTable.last

    def lastInstruction: Instruction = last._2

    def propagateCond(states: Map[BB, State]): Map[BB, State] = {
      val state@State(_, _, cond, _) = states(this)
      last._2.opcode match {
        case Opcode.IFLT | Opcode.IFLE | Opcode.IFGT | Opcode.IFGE |
             Opcode.IFEQ | Opcode.IFNE | Opcode.IFNULL | Opcode.IFNONNULL => {
          val falseSucc::trueSucc::Nil = cfg.succ(this)
          val falseState = state.copy(cond = simplify(cond match {
            case And(cond1, cond2) => And(cond1, Not(cond2))
            case _ => Not(cond)
          }))
          val trueState = state.copy(cond = simplify(cond))
          (states
            + (falseSucc -> (falseState + states.get(falseSucc)))
            + (trueSucc -> (trueState + states.get(trueSucc))))
        }
        case Opcode.IRETURN | Opcode.LRETURN | Opcode.FRETURN | Opcode.DRETURN |
             Opcode.ARETURN | Opcode.RETURN => states
        case _ =>
          val succ::Nil = cfg.succ(this)
          (states + (succ -> (state + states.get(succ))))
      }
    }
  }

  case class CFG(
    basicBlocks: List[BB],
    pred: Map[BB, List[BB]],
    succ: Map[BB, List[BB]])
  object CFG {
    def apply(lambdaReflection: LambdaReflection): CFG = {
      val codeIterator = lambdaReflection.codeIterator
      codeIterator.begin()
      val (labels, edges) = collectLabelsAndEdges(codeIterator)
      codeIterator.begin()
      val instructionTable = createInstructionTable(codeIterator)
      val (basicBlocks, offsetToBB) = createBasicBlocks(labels,
                                                        instructionTable)
      val (pred, succ) = connectBasicBlocks(basicBlocks, offsetToBB, edges)
      CFG(basicBlocks, pred, succ)
    }

    @tailrec
    private def collectLabelsAndEdges(
        codeIterator: CodeIterator,
        labels: SortedSet[Int] = SortedSet(),
        edges: SortedMap[Int, List[Int]] = SortedMap())
        : (SortedSet[Int], SortedMap[Int, List[Int]]) = {
      if (codeIterator.hasNext) {
        val offset = codeIterator.next
        val nextOffset = codeIterator.lookAhead
        val opcode = codeIterator.byteAt(offset)
        opcode match {
          case Opcode.IFEQ | Opcode.IFNE | Opcode.IFLT | Opcode.IFGE |
               Opcode.IFGT | Opcode.IFLE | Opcode.IFNULL | Opcode.IFNONNULL => {
            val falseOffset = nextOffset
            val trueOffset = offset + codeIterator.s16bitAt(offset + 1)
            collectLabelsAndEdges(
              codeIterator,
              labels + falseOffset + trueOffset,
              edges + (offset -> List(falseOffset, trueOffset)))
          }
          case Opcode.GOTO =>
            val labelOffset = offset + codeIterator.s16bitAt(offset + 1)
            collectLabelsAndEdges(
              codeIterator,
              labels + labelOffset,
              edges + (offset -> List(labelOffset)))
          case _ => collectLabelsAndEdges(codeIterator, labels, edges)
        }
      } else {
        (labels, edges)
      }
    }

    @tailrec
    private def createInstructionTable(
        codeIterator: CodeIterator,
        instructionTable: SortedMap[Int, Instruction] = SortedMap())
        : SortedMap[Int, Instruction] = {
      if (codeIterator.hasNext) {
        val offset = codeIterator.next
        val nextOffset = codeIterator.lookAhead
        val instruction = Instruction(codeIterator, offset)
        createInstructionTable(codeIterator,
                               instructionTable + (offset -> instruction))
      } else {
        instructionTable
      }
    }

    @tailrec
    private def createBasicBlocks(
        labels: SortedSet[Int],
        instructionTable: SortedMap[Int, Instruction],
        basicBlocks: List[BB] = List(),
        offsetToBB: IntMap[BB] = IntMap()): (List[BB], IntMap[BB]) = {
      if (labels.isEmpty) {
        val instructions = instructionTable
        val bb = BB(instructions)
        ((bb+:basicBlocks).reverse,
         instructions.foldLeft(offsetToBB) { case (offsetToBB, (offset, _)) =>
           offsetToBB + (offset -> bb)
         })
      } else {
        val (instructions, rest) = instructionTable.span(_._1 < labels.head)
        val bb = BB(instructions)
        createBasicBlocks(
          labels.tail, rest, bb+:basicBlocks,
          instructions.foldLeft(offsetToBB) { case (offsetToBB, (offset, _)) =>
            offsetToBB + (offset -> bb)
          })
      }
    }

    @tailrec
    private def connectBasicBlocks(
        basicBlocks: List[BB],
        offsetToBB: IntMap[BB],
        edges: SortedMap[Int, List[Int]],
        pred: Map[BB, List[BB]] = Map().withDefaultValue(Nil),
        succ: Map[BB, List[BB]] = Map().withDefaultValue(Nil))
        : (Map[BB, List[BB]], Map[BB, List[BB]]) = {
      if (basicBlocks.isEmpty) {
        (pred, succ)
      } else {
        val src::rest = basicBlocks
        val dst = edges.getOrElse(src.last._1,
                                  if (rest.isEmpty) {
                                    List()
                                  } else {
                                    List(rest.head.offset)
                                  }).map(offsetToBB)
        connectBasicBlocks(
          rest,
          offsetToBB,
          edges,
          dst.foldLeft(pred) { (p, l) => (p + (l -> (src::p(l)))) },
          succ + (src -> dst))
      }
    }
  }

  //
  // Reflection using SerializedLambda and javassist
  //
  case class LambdaReflection(private val classPool: ClassPool,
                              private val serializedLambda: SerializedLambda) {
    def lookupConstant(constPoolIndex: Int): Any = {
      constPool.getTag(constPoolIndex) match {
        case ConstPool.CONST_Integer => constPool.getIntegerInfo(constPoolIndex)
        case ConstPool.CONST_Long => constPool.getLongInfo(constPoolIndex)
        case ConstPool.CONST_Float => constPool.getFloatInfo(constPoolIndex)
        case ConstPool.CONST_Double => constPool.getDoubleInfo(constPoolIndex)
        case ConstPool.CONST_String => constPool.getStringInfo(constPoolIndex)
        case _ => throw new SparkException("Unsupported constant")
      }
    }

    def lookupField(constPoolIndex: Int): CtField = {
      if (constPool.getTag(constPoolIndex) != ConstPool.CONST_Fieldref) {
        throw new SparkException("Unexpected index for field reference")
      }
      val fieldName = constPool.getFieldrefName(constPoolIndex)
      val descriptor = constPool.getFieldrefType(constPoolIndex)
      val className = constPool.getFieldrefClassName(constPoolIndex)
      classPool.getCtClass(className).getField(fieldName, descriptor)
    }

    def lookupMethod(constPoolIndex: Int): CtMethod = {
      if (constPool.getTag(constPoolIndex) != ConstPool.CONST_Methodref) {
        throw new SparkException("Unexpected index for method reference")
      }
      val methodName = constPool.getMethodrefName(constPoolIndex)
      val descriptor = constPool.getMethodrefType(constPoolIndex)
      val className = constPool.getMethodrefClassName(constPoolIndex)
      classPool.getCtClass(className)
               .getDeclaredMethod(methodName,
                                  Descriptor.getParameterTypes(descriptor,
                                                               classPool))
    }

    private val ctClass = {
      val name = serializedLambda.getCapturingClass.replace('/', '.')
      classPool.insertClassPath(new ClassClassPath(classForName(name)))
      classPool.getCtClass(name)
    }

    private val ctMethod = {
      val lambdaImplName = serializedLambda.getImplMethodName
      ctClass.getDeclaredMethod(lambdaImplName.stripSuffix("$adapted"))
    }

    private val methodInfo = ctMethod.getMethodInfo

    private val constPool = methodInfo.getConstPool

    private val codeAttribute = methodInfo.getCodeAttribute

    lazy val codeIterator = codeAttribute.iterator

    lazy val parameters = ctMethod.getParameterTypes

    lazy val maxLocals = codeAttribute.getMaxLocals
  }
  object LambdaReflection {
    def apply(function: AnyRef): LambdaReflection = {
      // Reference for the use of SerialziedLambda to detect the lambda body:
      // getSerializedLambda in
      // spark/core/src/main/scala/org/apache/spark/util/ClosureCleaner.scala
      val functionClass = function.getClass
      val writeReplace = functionClass.getDeclaredMethod("writeReplace")
      writeReplace.setAccessible(true)
      val serializedLambda = writeReplace.invoke(function)
                                         .asInstanceOf[SerializedLambda]
      val classPool = ClassPool.getDefault
      LambdaReflection(classPool, serializedLambda)
    }
  }
}
