2c2
<  * Copyright (c) 2022, NVIDIA CORPORATION.
---
>  * Copyright (c) 2019-2022, NVIDIA CORPORATION.
23c23,25
< import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeReference, BinaryExpression, ComplexTypeMergingExpression, Expression, String2TrimExpression, TernaryExpression, TimeZoneAwareExpression, UnaryExpression, WindowExpression, WindowFunction}
---
> import com.nvidia.spark.rapids.shims.SparkShimImpl
> 
> import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeReference, BinaryExpression, ComplexTypeMergingExpression, Expression, QuaternaryExpression, String2TrimExpression, TernaryExpression, TimeZoneAwareExpression, UnaryExpression, WindowExpression, WindowFunction}
25a28,29
> import org.apache.spark.sql.catalyst.trees.TreeNodeTag
> import org.apache.spark.sql.connector.read.Scan
27c31
< import org.apache.spark.sql.execution.aggregate._
---
> import org.apache.spark.sql.execution.aggregate.BaseAggregateExec
30c34
< import org.apache.spark.sql.execution.window.WindowExec
---
> import org.apache.spark.sql.rapids.{CpuToGpuAggregateBufferConverter, GpuToCpuAggregateBufferConverter}
54a59
>   val gpuSupportedTag = TreeNodeTag[Set[String]]("rapids.gpu.supported")
67a73,74
>  * @tparam OUTPUT when converting to a GPU enabled version of the plan, the generic base
>  *                    type for all GPU enabled versions.
69c76
< abstract class RapidsMeta[INPUT <: BASE, BASE](
---
> abstract class RapidsMeta[INPUT <: BASE, BASE, OUTPUT <: BASE](
72c79
<     val parent: Option[RapidsMeta[_, _]],
---
>     val parent: Option[RapidsMeta[_, _, _]],
85a93,97
>    * The wrapped scans that should be examined
>    */
>   val childScans: Seq[ScanMeta[_]]
> 
>   /**
95a108,112
>    * Convert what this wraps to a GPU enabled version.
>    */
>   def convertToGpu(): OUTPUT
> 
>   /**
110a128
>   import RapidsMeta.gpuSupportedTag
127a146
>     childScans.foreach(_.recursiveCostPreventsRunningOnGpu())
133a153
>     childScans.foreach(_.recursiveSparkPlanPreventsRunningOnGpu())
140a161
>     childScans.foreach(_.recursiveSparkPlanRemoved())
158a180,185
>     wrapped match {
>       case p: SparkPlan =>
>         p.setTagValue(gpuSupportedTag,
>           p.getTagValue(gpuSupportedTag).getOrElse(Set.empty) + because)
>       case _ =>
>     }
218a246,250
>    * Returns true iff all of the scans can be replaced.
>    */
>   def canScansBeReplaced: Boolean = childScans.forall(_.canThisBeReplaced)
> 
>   /**
248a281
>     childScans.foreach(_.tagForGpu())
389a423
>     childScans.foreach(_.print(append, depth + 1, all))
412c446
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
414,416c448
<   extends RapidsMeta[INPUT, Partitioning](part, conf, parent, rule) {
<   // 2.x - replaced GpuPartitioning with Partitioning, should be fine
<   // since BASE only used for convert
---
>   extends RapidsMeta[INPUT, Partitioning, GpuPartitioning](part, conf, parent, rule) {
419a452
>   override val childScans: Seq[ScanMeta[_]] = Seq.empty
440c473
<     parent: Option[RapidsMeta[_, _]])
---
>     parent: Option[RapidsMeta[_, _, _]])
446a480,518
>   override def convertToGpu(): GpuPartitioning =
>     throw new IllegalStateException("Cannot be converted to GPU")
> }
> 
> /**
>  * Base class for metadata around `Scan`.
>  */
> abstract class ScanMeta[INPUT <: Scan](scan: INPUT,
>     conf: RapidsConf,
>     parent: Option[RapidsMeta[_, _, _]],
>     rule: DataFromReplacementRule)
>   extends RapidsMeta[INPUT, Scan, Scan](scan, conf, parent, rule) {
> 
>   override val childPlans: Seq[SparkPlanMeta[_]] = Seq.empty
>   override val childExprs: Seq[BaseExprMeta[_]] = Seq.empty
>   override val childScans: Seq[ScanMeta[_]] = Seq.empty
>   override val childParts: Seq[PartMeta[_]] = Seq.empty
>   override val childDataWriteCmds: Seq[DataWritingCommandMeta[_]] = Seq.empty
> 
>   override def tagSelfForGpu(): Unit = {}
> 
>   def supportsRuntimeFilters: Boolean = false
> }
> 
> /**
>  * Metadata for `Scan` with no rule found
>  */
> final class RuleNotFoundScanMeta[INPUT <: Scan](
>     scan: INPUT,
>     conf: RapidsConf,
>     parent: Option[RapidsMeta[_, _, _]])
>   extends ScanMeta[INPUT](scan, conf, parent, new NoRuleDataFromReplacementRule) {
> 
>   override def tagSelfForGpu(): Unit = {
>     willNotWorkOnGpu(s"GPU does not currently support the operator ${scan.getClass}")
>   }
> 
>   override def convertToGpu(): Scan =
>     throw new IllegalStateException("Cannot be converted to GPU")
455c527
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
457c529
<     extends RapidsMeta[INPUT, DataWritingCommand](cmd, conf, parent, rule) {
---
>     extends RapidsMeta[INPUT, DataWritingCommand, GpuDataWritingCommand](cmd, conf, parent, rule) {
460a533
>   override val childScans: Seq[ScanMeta[_]] = Seq.empty
473c546
<     parent: Option[RapidsMeta[_, _]])
---
>     parent: Option[RapidsMeta[_, _, _]])
478a552,554
> 
>   override def convertToGpu(): GpuDataWritingCommand =
>     throw new IllegalStateException("Cannot be converted to GPU")
486c562
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
488c564
<   extends RapidsMeta[INPUT, SparkPlan](plan, conf, parent, rule) {
---
>   extends RapidsMeta[INPUT, SparkPlan, GpuExec](plan, conf, parent, rule) {
493a570
>       childScans.foreach(_.recursiveSparkPlanPreventsRunningOnGpu())
498a576
>       childScans.foreach(_.recursiveSparkPlanRemoved())
523a602
>   override val childScans: Seq[ScanMeta[_]] = Seq.empty
559a639,643
> 
>       childPlans.head.wrapped
>           .getTagValue(GpuOverrides.preRowToColProjection).foreach { r2c =>
>         wrapped.setTagValue(GpuOverrides.preRowToColProjection, r2c)
>       }
601c685
<     /*if (!canScansBeReplaced) {
---
>     if (!canScansBeReplaced) {
603c687
<     } */
---
>     }
622a707,709
>     wrapped.getTagValue(RapidsMeta.gpuSupportedTag)
>       .foreach(_.diff(cannotBeReplacedReasons.get)
>       .foreach(willNotWorkOnGpu))
646c733,737
<       convertToCpu
---
>       if (canThisBeReplaced) {
>         convertToGpu()
>       } else {
>         convertToCpu()
>       }
716c807
<     parent: Option[RapidsMeta[_, _]])
---
>     parent: Option[RapidsMeta[_, _, _]])
720a812,814
> 
>   override def convertToGpu(): GpuExec =
>     throw new IllegalStateException("Cannot be converted to GPU")
729c823
<     parent: Option[RapidsMeta[_, _]])
---
>     parent: Option[RapidsMeta[_, _, _]])
736a831,833
> 
>   override def convertToGpu(): GpuExec =
>     throw new IllegalStateException("Cannot be converted to GPU")
777c874
<       case agg: SparkPlan if agg.isInstanceOf[WindowExec] =>
---
>       case agg: SparkPlan if SparkShimImpl.isWindowFunctionExec(agg) =>
779,786c876
<       case agg: HashAggregateExec =>
<         // Spark 2.x doesn't have the BaseAggregateExec class
<         if (agg.groupingExpressions.isEmpty) {
<           ReductionAggExprContext
<         } else {
<           GroupByAggExprContext
<         }
<       case agg: SortAggregateExec =>
---
>       case agg: BaseAggregateExec =>
797c887
<   def getRegularOperatorContext(meta: RapidsMeta[_, _]): ExpressionContext = meta.wrapped match {
---
>   def getRegularOperatorContext(meta: RapidsMeta[_, _, _]): ExpressionContext = meta.wrapped match {
853c943
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
855c945
<   extends RapidsMeta[INPUT, Expression](expr, conf, parent, rule) {
---
>   extends RapidsMeta[INPUT, Expression, Expression](expr, conf, parent, rule) {
861a952
>   override val childScans: Seq[ScanMeta[_]] = Seq.empty
911c1002
<       case tzAware: TimeZoneAwareExpression => checkTimeZoneId(tzAware.timeZone.toZoneId)
---
>       case tzAware: TimeZoneAwareExpression => checkTimeZoneId(tzAware.zoneId)
1004c1095
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
1006a1098,1099
> 
>   override def convertToGpu(): GpuExpression
1015c1108
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
1018a1112,1116
>   override final def convertToGpu(): GpuExpression =
>     convertToGpu(childExprs.head.convertToGpu())
> 
>   def convertToGpu(child: Expression): GpuExpression
> 
1034c1132
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
1045c1143
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
1050a1149,1151
>     if (needsAnsiCheck) {
>       GpuOverrides.checkAndTagAnsiAgg(ansiTypeToCheck, this)
>     }
1054a1156,1168
> 
>   override final def convertToGpu(): GpuExpression =
>     convertToGpu(childExprs.map(_.convertToGpu()))
> 
>   def convertToGpu(childExprs: Seq[Expression]): GpuExpression
> 
>   // Set to false if the aggregate doesn't overflow and therefore
>   // shouldn't error
>   val needsAnsiCheck: Boolean = true
> 
>   // The type to use to determine whether the aggregate could overflow.
>   // Set to None, if we should fallback for all types
>   val ansiTypeToCheck: Option[DataType] = Some(expr.dataType)
1063c1177
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
1065a1180,1181
> 
>   def convertToGpu(childExprs: Seq[Expression]): GpuExpression
1074c1190
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
1085a1202,1217
>    * Returns a buffer converter who can generate a Expression to transform the aggregation buffer
>    * of wrapped function from CPU format to GPU format. The conversion occurs on the CPU, so the
>    * generated expression should be a CPU Expression executed by row.
>    */
>   def createCpuToGpuBufferConverter(): CpuToGpuAggregateBufferConverter =
>     throw new NotImplementedError("The method should be implemented by specific functions")
> 
>   /**
>    * Returns a buffer converter who can generate a Expression to transform the aggregation buffer
>    * of wrapped function from GPU format to CPU format. The conversion occurs on the CPU, so the
>    * generated expression should be a CPU Expression executed by row.
>    */
>   def createGpuToCpuBufferConverter(): GpuToCpuAggregateBufferConverter =
>     throw new NotImplementedError("The method should be implemented by specific functions")
> 
>   /**
1099c1231
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
1101a1234,1240
> 
>   override final def convertToGpu(): GpuExpression = {
>     val Seq(lhs, rhs) = childExprs.map(_.convertToGpu())
>     convertToGpu(lhs, rhs)
>   }
> 
>   def convertToGpu(lhs: Expression, rhs: Expression): GpuExpression
1108c1247
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
1126c1265
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
1128a1268,1294
> 
>   override final def convertToGpu(): GpuExpression = {
>     val Seq(child0, child1, child2) = childExprs.map(_.convertToGpu())
>     convertToGpu(child0, child1, child2)
>   }
> 
>   def convertToGpu(val0: Expression, val1: Expression,
>                    val2: Expression): GpuExpression
> }
> 
> /**
>  * Base class for metadata around `QuaternaryExpression`.
>  */
> abstract class QuaternaryExprMeta[INPUT <: QuaternaryExpression](
>     expr: INPUT,
>     conf: RapidsConf,
>     parent: Option[RapidsMeta[_, _, _]],
>     rule: DataFromReplacementRule)
>   extends ExprMeta[INPUT](expr, conf, parent, rule) {
> 
>   override final def convertToGpu(): GpuExpression = {
>     val Seq(child0, child1, child2, child3) = childExprs.map(_.convertToGpu())
>     convertToGpu(child0, child1, child2, child3)
>   }
> 
>   def convertToGpu(val0: Expression, val1: Expression,
>     val2: Expression, val3: Expression): GpuExpression
1134c1300
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
1136a1303,1309
> 
>   override final def convertToGpu(): GpuExpression = {
>     val gpuCol :: gpuTrimParam = childExprs.map(_.convertToGpu())
>     convertToGpu(gpuCol, gpuTrimParam.headOption)
>   }
> 
>   def convertToGpu(column: Expression, target: Option[Expression] = None): GpuExpression
1145c1318
<     parent: Option[RapidsMeta[_, _]],
---
>     parent: Option[RapidsMeta[_, _, _]],
1147a1321,1324
>   override final def convertToGpu(): GpuExpression =
>     convertToGpu(childExprs.map(_.convertToGpu()))
> 
>   def convertToGpu(childExprs: Seq[Expression]): GpuExpression
1156c1333
<     parent: Option[RapidsMeta[_, _]])
---
>     parent: Option[RapidsMeta[_, _, _]])
1160a1338,1340
> 
>   override def convertToGpu(): GpuExpression =
>     throw new IllegalStateException("Cannot be converted to GPU")
