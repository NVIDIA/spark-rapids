2c2
<  * Copyright (c) 2022, NVIDIA CORPORATION.
---
>  * Copyright (c) 2020-2021, NVIDIA CORPORATION.
19d18
< import java.time.Instant
21d19
< import java.util.concurrent.TimeUnit._
24a23,25
> import ai.rapids.cudf.{DType, Scalar}
> import com.nvidia.spark.rapids.VersionUtils.isSpark320OrLater
> 
25a27
> import org.apache.spark.sql.catalyst.util.DateTimeUtils.localDateToDays
61,62c63,65
<   // Spark 2.x - removed isSpark320orlater checks
<   def specialDatesDays: Map[String, Int] = {
---
>   def specialDatesDays: Map[String, Int] = if (isSpark320OrLater) {
>     Map.empty
>   } else {
73c76,78
<   def specialDatesSeconds: Map[String, Long] =  {
---
>   def specialDatesSeconds: Map[String, Long] = if (isSpark320OrLater) {
>     Map.empty
>   } else {
75c80
<     val now = instantToMicros(Instant.now())
---
>     val now = DateTimeUtils.currentTimestamp()
85c90,92
<   def specialDatesMicros: Map[String, Long] = {
---
>   def specialDatesMicros: Map[String, Long] = if (isSpark320OrLater) {
>     Map.empty
>   } else {
87c94
<     val now = instantToMicros(Instant.now())
---
>     val now = DateTimeUtils.currentTimestamp()
97c104,121
<   def currentDate(): Int = Math.toIntExact(LocalDate.now().toEpochDay)
---
>   def fetchSpecialDates(unit: DType): Map[String, () => Scalar] = unit match {
>     case DType.TIMESTAMP_DAYS =>
>       DateUtils.specialDatesDays.map { case (k, v) =>
>         k -> (() => Scalar.timestampDaysFromInt(v))
>       }
>     case DType.TIMESTAMP_SECONDS =>
>       DateUtils.specialDatesSeconds.map { case (k, v) =>
>         k -> (() => Scalar.timestampFromLong(unit, v))
>       }
>     case DType.TIMESTAMP_MICROSECONDS =>
>       DateUtils.specialDatesMicros.map { case (k, v) =>
>         k -> (() => Scalar.timestampFromLong(unit, v))
>       }
>     case _ =>
>       throw new IllegalArgumentException(s"unsupported DType: $unit")
>   }
> 
>   def currentDate(): Int = localDateToDays(LocalDate.now())
190,211d213
< 
<   // pull in some unit and DateTimeUtils stuff because 2.3.X doesn't have it
<   final val MILLIS_PER_SECOND = 1000L;
<   final val MICROS_PER_MILLIS = 1000L;
<   final val MICROS_PER_SECOND = MILLIS_PER_SECOND * MICROS_PER_MILLIS;
<   private val MIN_SECONDS = Math.floorDiv(Long.MinValue, MICROS_PER_SECOND)
< 
<  /**
<   * Gets the number of microseconds since the epoch of 1970-01-01 00:00:00Z from the given
<   * instance of `java.time.Instant`. The epoch microsecond count is a simple incrementing count of
<   * microseconds where microsecond 0 is 1970-01-01 00:00:00Z.
<   */
<   def instantToMicros(instant: Instant): Long = {
<     val secs = instant.getEpochSecond
<     if (secs == MIN_SECONDS) {
<       val us = Math.multiplyExact(secs + 1, MICROS_PER_SECOND)
<       Math.addExact(us, NANOSECONDS.toMicros(instant.getNano) - MICROS_PER_SECOND)
<     } else {
<       val us = Math.multiplyExact(secs, MICROS_PER_SECOND)
<       Math.addExact(us, NANOSECONDS.toMicros(instant.getNano))
<     }
<   }
