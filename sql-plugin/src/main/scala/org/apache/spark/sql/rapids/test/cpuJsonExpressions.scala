/*
 * Copyright (c) 2024, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.spark.sql.rapids.test

import java.io.FileWriter
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import java.util.Objects

import ai.rapids.cudf.{ColumnVector, DType, HostColumnVector}
import com.nvidia.spark.rapids.{GpuColumnVector, GpuScalar}
import com.nvidia.spark.rapids.Arm.withResource
import com.univocity.parsers.csv.{CsvWriter, CsvWriterSettings}

import org.apache.spark.sql.catalyst.expressions.{GetJsonObject, Literal}
import org.apache.spark.sql.types.StringType
import org.apache.spark.unsafe.types.UTF8String

case class CsvWriterWrapper(filePath: String) extends AutoCloseable {
  // create file writer with append mode
  private val writer: FileWriter = new FileWriter(filePath, true)
  private val csvWriter: CsvWriter = new CsvWriter(writer, new CsvWriterSettings())

  override def close(): Unit = {
    if (csvWriter != null) {
      csvWriter.close()
    }
    if (writer != null) {
      writer.close()
    }
  }

  def writeRow(row: Array[String]): Unit = {
    csvWriter.writeRow(row)
  }
}

object GetJsonObjectMask {

  /**
   * Used by mask data
   */
  private val RETAIN_CHARS_FOR_JSON = Set[Char](
    '{', '}', '[', ']', ',', ':', '"', '\'',
    '\\', '/', 'b', 'f', 'n', 'r', 't', 'u',
    '-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'e', 'E',
    'u', 'A', 'a', 'B', 'b', 'C', 'c', 'D', 'd', 'E', 'e', 'F', 'f',
    't', 'r', 'u', 'e',
    'f', 'a', 'l', 's', 'e',
    'n', 'u', 'l', 'l'
  )

  /**
   * Mask data. RAPIDS Accelerator should now dump the original Customer data.
   * This dump tool only care about the functionality of get-json-object, so just replace
   * characters to a const 's' except the following cases:
   *     { } [ ] , : " ' :  JSON structure chars, should not replace
   *     \  :  escape char, should not replace
   *     / b f n r t u : can follow \, should not replace
   *     - :  used by number, should not replace
   *     0-9  : used by number, should not replace
   *     e E  : used by number, e,g,: 1.0E-3, should not replace
   *     u A-F a-f : used by unicode: \u HEX HEX HEX HEX, should not replace
   *     true :  should not replace
   *     false :  should not replace
   *     null :  should not replace
   * To simplify more,
   * Replace all the chars to 's' except above chars, including chars in true, false, null.
   *
   * @param jsonStr original JSON data
   * @return Desensitized data
   */
  def maskData(jsonStr: String): String = {
    replaceIfNotRetain(jsonStr, RETAIN_CHARS_FOR_JSON)
  }

  // used by mask path
  private val RETAIN_CHARS_FOR_PATH = Set[Char]('$', '[', ']', '*', '.')

  /**
   * mask path
   * @param pathStr original path
   * @return masked path
   */
  def maskPath(pathStr: String): String = {
    replaceIfNotRetain(pathStr, RETAIN_CHARS_FOR_PATH)
  }

  /**
   * Replace chars not in `retainChars` to const char 's' to mask data
   * @param originStr origin string
   * @param retainChars retain chars
   * @return masked string
   */
  private def replaceIfNotRetain(originStr: String, retainChars: Set[Char] ): String = {
    if (originStr != null) {
      val buf = new StringBuffer(originStr.length)
      var idx = 0
      while (idx < originStr.length) {
        if (!retainChars.contains(originStr(idx))) {
          // if it's not a retain char, replace to a const char 's'
          buf.append('s')
        } else {
          buf.append(originStr(idx))
        }
        idx += 1
      }
      buf.toString
    } else {
      null
    }
  }
}

object CpuGetJsonObject {
  /**
   * verify results from Cpu and Gpu, save diffs if have
   * @param dataCv original JSON data
   * @param path the path to extract JSON data
   * @param fromGpuCv result from GPU
   * @param fromCpuHCV result from CPU
   * @param savePathForVerify save path if have diffs
   * @param saveRowsForVerify max diff rows to save, Note: only take effective for current data
   */
  def verify(
      dataCv: ColumnVector,
      path: UTF8String,
      fromGpuCv: ColumnVector,
      fromCpuHCV: HostColumnVector,
      savePathForVerify: String,
      saveRowsForVerify: Int): Unit = {
    withResource(dataCv.copyToHost()) { dataHCV =>
      withResource(fromGpuCv.copyToHost()) { fromGpuHCV =>
        // save file is generated by date: yyyyMMdd.csv
        val savePath = savePathForVerify +
            DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now()) + ".csv"
        withResource(CsvWriterWrapper(savePath)) { csvWriter =>
          val pathStr = if (path == null) "null" else path.toString
          var currRow = 0
          var diffRowsNum = 0
          while (currRow < dataCv.getRowCount.toInt &&
              diffRowsNum < saveRowsForVerify
          ) {
            val str = dataHCV.getJavaString(currRow)
            val cpuStr = if (fromCpuHCV.isNull(currRow)) null else fromCpuHCV.getJavaString(currRow)
            val gpuStr = if (fromGpuHCV.isNull(currRow)) null else fromGpuHCV.getJavaString(currRow)
            if (!Objects.equals(cpuStr, gpuStr)) { // if have diff
              diffRowsNum += 1

              // mask customer data
              val maskedPath = GetJsonObjectMask.maskPath(pathStr)
              val maskedOriginJson = GetJsonObjectMask.maskData(str)
              val maskedCpuRet = GetJsonObjectMask.maskData(cpuStr)
              val maskedGpuRet = GetJsonObjectMask.maskData(gpuStr)

              // append to csv file: yyyyMMdd.csv
              csvWriter.writeRow(Array(maskedPath, maskedOriginJson, maskedCpuRet, maskedGpuRet))
            }
            currRow += 1
          }
        }
      }
    }
  }

  /**
   * Run get-json-object on CPU
   * @param dataCv original JSON data
   * @param pathScalar path scalar
   * @return CPU result of get-json-object
   */
  def getJsonObjectOnCpu(dataCv: GpuColumnVector, pathScalar: GpuScalar): HostColumnVector = {
    withResource(dataCv.copyToHost()) { dataHCV =>
      withResource(HostColumnVector.builder(DType.STRING, dataHCV.getRowCount.toInt)) {
        resultBuilder =>
          val path = pathScalar.getValue.asInstanceOf[UTF8String]
          val pathLiteral = Literal.create(path, StringType)
          for (i <- 0 until dataHCV.getRowCount.toInt) {
            val json = dataHCV.getUTF8String(i)
            // In order to use `GetJsonObject` directly,
            // here use a literal json and a literal path
            val jsonLiteral = Literal.create(json, StringType)
            val cpuGetJsonObject = GetJsonObject(jsonLiteral, pathLiteral)
            // input null is safe because both json and path are literal
            val utf8String = cpuGetJsonObject.eval(null)
            if (utf8String == null) {
              resultBuilder.appendNull()
            } else {
              resultBuilder.append(utf8String.toString)
            }
          }
          resultBuilder.build()
      }
    }
  }
}
